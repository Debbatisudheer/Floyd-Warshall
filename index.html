<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floyd-Warshall Algorithm</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>Floyd-Warshall Algorithm</h1>
        <p>The Floyd-Warshall algorithm is a dynamic programming algorithm used for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles). It works for both directed and undirected graphs.</p>
        <h2>Algorithm Details:</h2>
        <ul>
            <li>Time Complexity: O(V^3)</li>
            <li>Space Complexity: O(V^2)</li>
             <h1>Time and Space Complexity of Floyd-Warshall Algorithm</h1>

        <h2>Time Complexity (How Long It Takes):</h2>
        <p>Imagine you have a certain number of airports. With the Floyd-Warshall algorithm, if you double the number of airports, the time it takes to find the shortest routes will roughly increase by eight times. So, the time it takes to find the shortest routes grows fairly quickly as you add more airports.</p>

        <h2>Space Complexity (How Much Memory It Uses):</h2>
        <p>If you have a certain number of airports, the Floyd-Warshall algorithm needs memory space to store information about the shortest routes between all pairs of airports. The amount of memory it needs grows with the square of the number of airports. So, if you double the number of airports, the amount of memory needed increases by four times.</p>

        <p>In simple terms, the Floyd-Warshall algorithm may take longer to find the shortest routes if you have a lot of airports, and it also requires more memory space to do its calculations as the number of airports increases. But for a moderate number of airports, it works well and efficiently.</p>
        </ul>
        <img src="warshall.png" alt="Floyd-Warshall Algorithm Image">
        <p>In the provided graph, we have taken 5 nodes labeled as A, B, C, D, and E. These nodes are connected by 7 directed edges with weights assigned to them.</p>
         <h2>Shortest distances between all pairs of nodes:</h2>
        <p>Distance from Node A to Node A: 0</p>
        <p>Distance from Node A to Node B: 2</p>
        <p>Distance from Node A to Node C: -1</p>
        <p>Distance from Node A to Node D: -3</p>
        <p>Distance from Node A to Node E: -6</p>
        <p>Distance from Node B to Node B: 0</p>
        <p>Distance from Node B to Node C: 3</p>
        <p>Distance from Node B to Node D: -5</p>
        <p>Distance from Node B to Node E: -8</p>
        <p>Distance from Node C to Node C: 0</p>
        <p>Distance from Node C to Node D: 1</p>
        <p>Distance from Node C to Node E: -2</p>
        <p>Distance from Node D to Node D: 0</p>
        <p>Distance from Node D to Node E: -3</p>
        <p>Distance from Node E to Node E: 0</p>
         <h2>Shortest distances between all pairs of nodes:</h2>
        <table>
            <tr>
                <td></td>
                <td>A</td>
                <td>B</td>
                <td>C</td>
                <td>D</td>
                <td>E</td>
            </tr>
            <tr>
                <td>A</td>
                <td>0</td>
                <td>2</td>
                <td>-1</td>
                <td>-3</td>
                <td>-6</td>
            </tr>
            <tr>
                <td>B</td>
                <td>∞</td>
                <td>0</td>
                <td>3</td>
                <td>-5</td>
                <td>-8</td>
            </tr>
            <tr>
                <td>C</td>
                <td>∞</td>
                <td>∞</td>
                <td>0</td>
                <td>1</td>
                <td>-2</td>
            </tr>
            <tr>
                <td>D</td>
                <td>∞</td>
                <td>∞</td>
                <td>∞</td>
                <td>0</td>
                <td>-3</td>
            </tr>
            <tr>
                <td>E</td>
                <td>∞</td>
                <td>∞</td>
                <td>∞</td>
                <td>∞</td>
                <td>0</td>
            </tr>
        </table>
        <p>In this table:</p>
        <ul>
            <li>"∞" represents infinity, indicating that there is no direct path from the source node to the destination node.</li>
            <li>The diagonal elements (A-A, B-B, C-C, D-D, E-E) are all 0, indicating that the distance from a node to itself is always 0.</li>
        </ul>
    </div>
      <div class="container">
        <h1>The Floyd-Warshall Algorithm</h1>
        <p>The Floyd-Warshall algorithm is a method used to find the shortest paths between all pairs of vertices in a weighted graph. Let's break down how it works step by step:</p>

        <h2>Initialization:</h2>
        <ul>
            <li>We start by initializing a matrix (let's call it the distance matrix) where each cell [i][j] represents the shortest distance from vertex i to vertex j.</li>
            <li>Initially, this matrix is filled with the direct edge weights between vertices if an edge exists. If there's no direct edge between vertices i and j, the distance is set to infinity.</li>
            <li>Additionally, we initialize the diagonal of the matrix to zeros since the shortest distance from a vertex to itself is always zero.</li>
        </ul>

        <h2>Iterative Updates:</h2>
        <ul>
            <li>The algorithm then iterates through all vertices in the graph (let's call the current vertex k).</li>
            <li>For each pair of vertices i and j, it checks if the shortest path from vertex i to vertex j can be improved by including vertex k as an intermediate vertex. If the path going through vertex k is shorter, we update the distance matrix accordingly.</li>
            <li>The algorithm repeats this process for every vertex in the graph. Each iteration updates the shortest distances between all pairs of vertices by considering all possible intermediate vertices.</li>
        </ul>

        <h2>Final Result:</h2>
        <ul>
            <li>Once all vertices have been considered as potential intermediate vertices, the distance matrix will contain the shortest distances between all pairs of vertices in the graph.</li>
        </ul>

        <h2>Path Reconstruction (Optional):</h2>
        <ul>
            <li>If needed, the shortest paths themselves can be reconstructed from the distance matrix by backtracking through the intermediate vertices stored during the algorithm's execution.</li>
        </ul>

        <h2>Handling Negative Cycles:</h2>
        <ul>
            <li>One important aspect to note is that the Floyd-Warshall algorithm can handle graphs with negative edge weights, but it cannot handle negative cycles. A negative cycle is a cycle whose total edge weights sum to a negative value. If the graph contains a negative cycle, the algorithm will detect it during its execution.</li>
        </ul>

        <p>In summary, the Floyd-Warshall algorithm efficiently computes the shortest paths between all pairs of vertices in a graph by iteratively updating a matrix of shortest distances. It's a straightforward and robust method for solving this problem and is particularly useful for dense graphs where other algorithms might be less efficient.</p>
    </div>
     <div class="container">
        <h1>The Floyd-Warshall Algorithm</h1>
        <p>Imagine you have a map with many cities connected by roads. Each road has a certain length. Now, you want to find the shortest route between every pair of cities on the map.</p>

        <p>The Floyd-Warshall algorithm helps you do just that. Here's how:</p>

        <h2>Start with what you know:</h2>
        <ul>
            <li>First, you make a chart (or a matrix) that shows the distance between every pair of cities you're interested in. If there's a direct road between two cities, you put the road length in the chart. If there's no direct road, you put a really big number to show that it's "infinity" or that there's no direct path.</li>
        </ul>

        <h2>Check all possibilities:</h2>
        <ul>
            <li>Now, you start looking at all possible routes between cities. You consider each city as a potential stopover or "middle point" between two other cities. You check if going through this middle city makes the route shorter.</li>
        </ul>

        <h2>Update the chart:</h2>
        <ul>
            <li>Whenever you find a shorter route by going through a middle city, you update your chart to show this shorter distance.</li>
        </ul>

        <h2>Keep checking:</h2>
        <ul>
            <li>You keep doing this for every possible combination of cities, considering each city as a potential middle stop.</li>
        </ul>

        <h2>Finish up:</h2>
        <ul>
            <li>After you've checked all the possibilities, you'll have a chart that shows the shortest routes between every pair of cities.</li>
        </ul>

        <h2>Bonus:</h2>
        <ul>
            <li>If you want, you can also figure out exactly which roads you need to take for each shortest route by keeping track of the "middle points" you used along the way.</li>
        </ul>

        <p>And that's it! The Floyd-Warshall algorithm helps you find the shortest paths between all pairs of cities on your map by checking all possible routes and updating the distances as needed. It's like finding the best way to get from every city to every other city on your map.</p>
    </div>
 <div class="container">
        <h1>Comparison of Graph Shortest Path Algorithms</h1>

        <h2>Floyd-Warshall Algorithm:</h2>
        <ul>
            <li>Purpose: Finds the shortest paths between all pairs of vertices in a weighted graph.</li>
            <li>Edge Weights: Can handle both positive and negative edge weights but cannot handle negative cycles.</li>
            <li>Complexity: Time complexity is O(V^3), where V is the number of vertices, making it suitable for dense graphs.</li>
            <li>Usage: Often used for small or medium-sized graphs where finding the shortest paths between all pairs of vertices is required.</li>
        </ul>

        <h2>Dijkstra's Algorithm:</h2>
        <ul>
            <li>Purpose: Finds the shortest paths from a single source vertex to all other vertices in a weighted graph.</li>
            <li>Edge Weights: Works only with non-negative edge weights.</li>
            <li>Complexity: Time complexity ranges from O(V^2) to O(E + V log V), where V is the number of vertices and E is the number of edges, depending on the implementation (e.g., with priority queues).</li>
            <li>Usage: Ideal for finding shortest paths from a single source vertex in graphs with non-negative edge weights.</li>
        </ul>

        <h2>Bellman-Ford Algorithm:</h2>
        <ul>
            <li>Purpose: Finds the shortest paths from a single source vertex to all other vertices in a weighted graph, even when negative edge weights or negative cycles are present.</li>
            <li>Edge Weights: Can handle negative edge weights and detect negative cycles.</li>
            <li>Complexity: Time complexity is O(VE), where V is the number of vertices and E is the number of edges.</li>
            <li>Usage: Commonly used when there might be negative edge weights or cycles in the graph, but it's less efficient than Dijkstra's algorithm for graphs without negative weights.</li>
        </ul>

        <h2>Main Differences:</h2>
        <ul>
            <li>The Floyd-Warshall algorithm finds shortest paths between all pairs of vertices, while Dijkstra's algorithm and Bellman-Ford algorithm focus on finding shortest paths from a single source vertex.</li>
            <li>Floyd-Warshall can handle both positive and negative edge weights but cannot handle negative cycles, whereas Bellman-Ford can handle negative edge weights and detect negative cycles.</li>
            <li>Dijkstra's algorithm works only with non-negative edge weights, making it faster in such cases compared to Bellman-Ford or Floyd-Warshall.</li>
        </ul>

        <p>In summary, each algorithm has its strengths and weaknesses, and the choice depends on factors such as the type of graph (weighted, directed, etc.), presence of negative weights or cycles, and the specific requirements of the application.</p>
    </div>
  <div class="container">
        <h1>Potential Projects for Applying the Floyd-Warshall Algorithm</h1>

        <ul>
            <li><strong>Airline Route Optimization:</strong> Develop a system to optimize flight routes for airlines, considering factors such as time, fuel consumption, passenger demand, and operational constraints.</li>
            <li>Network Routing in Communication Networks: Optimize routing in communication networks, such as the internet or telecommunications networks, to minimize latency, packet loss, and network congestion.</li>
            <li>Transportation Network Optimization: Apply the algorithm to optimize transportation networks, including road networks, public transit systems, and shipping routes, to improve traffic flow, reduce travel time, and minimize fuel consumption.</li>
            <li>Supply Chain Management: Optimize supply chain logistics, including warehouse location selection, inventory management, and transportation route planning, to minimize costs and streamline operations.</li>
            <li>Urban Planning: Analyze and optimize urban transportation networks, including public transit routes, road infrastructure, and pedestrian pathways, to improve accessibility and mobility within cities.</li>
            <li>Disaster Response Planning: Optimize evacuation routes and emergency response plans for natural disasters or other emergencies, ensuring efficient and timely evacuation and resource allocation.</li>
            <li>Robot Path Planning: Plan optimal paths for robots or autonomous vehicles navigating through environments with obstacles, avoiding collisions and optimizing travel time.</li>
            <li>Social Network Analysis: Analyze social networks and identify influential nodes or communities within the network, facilitating targeted marketing, information dissemination, or community detection.</li>
            <li>Genetic Algorithms: Combine the Floyd-Warshall algorithm with genetic algorithms or other metaheuristic optimization techniques to solve complex optimization problems in various domains, such as scheduling, routing, and resource allocation.</li>
            <li>Game Development: Implement the algorithm in game development for pathfinding algorithms in video games, such as finding the shortest path for characters or units to navigate through game environments.</li>
        </ul>

        <p>These projects span a wide range of applications and industries, offering opportunities to apply the Floyd-Warshall algorithm to solve real-world problems and optimize systems and processes. Choose a project that aligns with your interests and expertise, and explore how the algorithm can be adapted and implemented to address specific challenges in that domain.</p>
    </div>
<div class="container">
        <h1>Performance Analysis of Floyd-Warshall Algorithm</h1>

        <p>Graph size: 100x100, Execution time: 0.220646 seconds, Space complexity: 80000 bytes</p>
        <p>Graph size: 200x200, Execution time: 1.726045 seconds, Space complexity: 320000 bytes</p>
        <p>Graph size: 300x300, Execution time: 5.685421 seconds, Space complexity: 720000 bytes</p>
        <p>Graph size: 400x400, Execution time: 13.452096 seconds, Space complexity: 1280000 bytes</p>
        <p>Graph size: 500x500, Execution time: 26.514061 seconds, Space complexity: 2000000 bytes</p>
    </div>
     <div class="container">
        <h1>Analysis of Floyd-Warshall Algorithm Performance</h1>

        <h2>Time Complexity:</h2>
        <ul>
            <li>As the graph size increases (measured by the number of vertices), the execution time also increases.</li>
            <li>The execution time approximately doubles each time the graph size (number of vertices) doubles.</li>
            <li>For example, the execution time increases from approximately 0.22 seconds for a graph size of 100x100 to approximately 26.51 seconds for a graph size of 500x500.</li>
            <li>This behavior suggests that the time complexity of the Floyd-Warshall algorithm is closer to O(V^3), where V is the number of vertices (or airports in this case). This is because the execution time increases rapidly as the graph size grows.</li>
        </ul>

        <h2>Space Complexity:</h2>
        <ul>
            <li>Similarly, as the graph size increases, the space complexity (memory usage) also increases.</li>
            <li>The space complexity approximately quadruples each time the graph size doubles.</li>
            <li>For example, the space complexity increases from 80,000 bytes for a graph size of 100x100 to 2,000,000 bytes for a graph size of 500x500.</li>
            <li>This behavior suggests that the space complexity of the Floyd-Warshall algorithm is closer to O(V^2), where V is the number of vertices (or airports in this case). This is because the space required to store the distances between all pairs of vertices grows quadratically with the number of vertices.</li>
        </ul>

        <p>Therefore, based on the provided data, the Floyd-Warshall algorithm exhibits a time complexity closer to O(V^3) and a space complexity closer to O(V^2), where V is the number of vertices in the graph.</p>
    </div>
     <div class="container">
        <h1>When to Use and Not to Use Floyd-Warshall Algorithm</h1>

        <h2>When to use Floyd-Warshall:</h2>
        <ul>
            <li>Finding shortest paths between all pairs of vertices: Floyd-Warshall is specifically designed for this task and is highly efficient for dense graphs or graphs with small to moderate numbers of vertices.</li>
            <li>Weighted graphs with positive or negative edge weights: Floyd-Warshall can handle graphs with both positive and negative edge weights, including negative cycles. This makes it suitable for a wide range of applications.</li>
            <li>Static graphs: If the graph structure remains constant or changes infrequently, Floyd-Warshall can be precomputed and used to efficiently answer shortest path queries.</li>
            <li>Small to medium-sized graphs: Floyd-Warshall's time complexity of O(V^3) makes it practical for graphs with up to a few hundred vertices. It may outperform other algorithms like Dijkstra's algorithm for dense graphs with small edge weights.</li>
        </ul>

        <h2>When not to use Floyd-Warshall:</h2>
        <ul>
            <li>Large graphs: The cubic time complexity of Floyd-Warshall (O(V^3)) makes it inefficient for very large graphs with thousands or millions of vertices.</li>
            <li>Dynamic graphs: If the graph structure changes frequently or dynamically, recomputing the entire Floyd-Warshall matrix for each change may be impractical. In such cases, incremental algorithms like Dijkstra's or A* may be more suitable.</li>
            <li>Memory constraints: Floyd-Warshall's space complexity of O(V^2) can be prohibitive for very large graphs with many vertices, especially if the graph is sparse. In such cases, memory-efficient alternatives may be preferred.</li>
            <li>Non-weighted graphs: If the graph is unweighted or has uniform edge weights, simpler algorithms like breadth-first search (BFS) or depth-first search (DFS) may suffice and provide better performance.</li>
        </ul>

        <p>In summary, Floyd-Warshall is a powerful algorithm for finding shortest paths in graphs, especially for small to medium-sized graphs with arbitrary edge weights. However, its cubic time complexity and quadratic space complexity can make it less practical for very large or dynamic graphs. It's essential to consider the characteristics of your graph and the specific requirements of your application when deciding whether to use Floyd-Warshall or alternative algorithms.</p>
    </div>
     <div class="container">
        <h1>Applications of Floyd-Warshall Algorithm</h1>

        <ul>
            <li>Network Routing: In computer networks, Floyd-Warshall can be used to determine the shortest paths between all pairs of routers or nodes, helping to optimize routing tables and improve network efficiency.</li>
            <li>Urban Transportation Planning: Floyd-Warshall can assist urban planners in analyzing transportation networks to optimize routes for buses, trains, or other modes of public transportation, considering factors such as travel time and distance.</li>
            <li>Airline Route Optimization: Airlines can use Floyd-Warshall to optimize flight routes, considering factors like travel time, fuel consumption, and passenger demand, to minimize costs and improve scheduling efficiency.</li>
            <li>Navigation Systems: Navigation systems in vehicles or mobile applications can utilize Floyd-Warshall to calculate the shortest routes between all pairs of locations, providing users with optimal directions and travel times.</li>
            <li>Telecommunication Networks: Telecommunication companies can apply Floyd-Warshall to analyze communication networks and optimize the routing of data packets, ensuring efficient data transmission and network reliability.</li>
            <li>Traffic Management: City traffic management systems can employ Floyd-Warshall to model traffic flow and optimize traffic signal timings, reducing congestion and improving overall traffic flow.</li>
            <li>Supply Chain Management: Companies involved in supply chain management can use Floyd-Warshall to optimize logistics networks, minimizing transportation costs and delivery times by finding the most efficient routes between warehouses, distribution centers, and customers.</li>
            <li>Game Development: In game development, Floyd-Warshall can be used to implement pathfinding algorithms for characters or entities in virtual environments, ensuring efficient navigation and obstacle avoidance.</li>
            <li>Robotics: Robotics applications, such as autonomous vehicles or drones, can benefit from Floyd-Warshall for path planning in dynamic environments, allowing robots to navigate safely and efficiently.</li>
            <li>Geographical Information Systems (GIS): GIS applications can utilize Floyd-Warshall to analyze spatial data and calculate the shortest paths between geographic locations, facilitating route planning, emergency response, and resource allocation.</li>
        </ul>
    </div>
 <div class="container">
        <h1>Complexities of Floyd-Warshall Algorithm</h1>

        <h2>Time Complexity O(V^3):</h2>
        <ul>
            <li>The algorithm iterates through all vertices as intermediate points to update the shortest paths between every pair of vertices.</li>
            <li>For each intermediate vertex k, it considers all pairs of vertices i and j and checks if the path from i to j through k is shorter than the current shortest path.</li>
            <li>This nested loop structure results in a time complexity of O(V^3), where V is the number of vertices in the graph.</li>
            <li>As the number of vertices increases, the time taken by the algorithm grows cubically, making it less efficient for large graphs.</li>
        </ul>

        <h2>Space Complexity O(V^2):</h2>
        <ul>
            <li>The algorithm requires a V×V matrix to store the shortest distances between all pairs of vertices.</li>
            <li>Each entry in the matrix represents the shortest distance between two vertices.</li>
            <li>Therefore, the space complexity is O(V^2), as the matrix size is proportional to the square of the number of vertices.</li>
            <li>Even though the matrix is symmetric (since the shortest distance from i to j is the same as from j to i), the algorithm still needs to store all entries in the matrix.</li>
            <li>As the number of vertices increases, the space required by the matrix grows quadratically, which can become significant for large graphs.</li>
        </ul>
    </div>
 <div class="container">
        <h1>Dynamic Programming in Floyd-Warshall Algorithm</h1>

        <h2>Initialization:</h2>
        <ul>
            <li>The algorithm initializes a distance matrix, where each entry dist[i][j] represents the shortest distance from vertex i to vertex j.</li>
            <li>Initially, this matrix is filled with the direct edge weights between vertices, if there is an edge, or infinity if there is no direct edge.</li>
        </ul>

        <h2>Dynamic Programming Iteration:</h2>
        <ul>
            <li>The algorithm iterates over all vertices k, considering each vertex as a potential intermediate vertex in the shortest path between two other vertices.</li>
            <li>For each pair of vertices i and j, it checks if going through vertex k would result in a shorter path compared to the current shortest path between i and j.</li>
            <li>If the path through vertex k is shorter, the distance matrix is updated accordingly to reflect this new shortest path.</li>
        </ul>

        <h2>Optimal Substructure:</h2>
        <ul>
            <li>The algorithm leverages the optimal substructure property, which states that a globally optimal solution can be constructed from optimal solutions to smaller subproblems.</li>
            <li>By iteratively considering all possible intermediate vertices k, the algorithm builds up the shortest paths between all pairs of vertices from smaller subproblems to larger ones.</li>
        </ul>

        <h2>Memoization:</h2>
        <ul>
            <li>Although Floyd-Warshall does not use explicit memoization like other dynamic programming algorithms, it achieves a similar effect by storing intermediate results in the distance matrix.</li>
            <li>The algorithm avoids redundant calculations by storing and reusing the shortest distances between all pairs of vertices as it iterates through the vertices.</li>
        </ul>
    </div>

    <footer>
        @sudheer debbati all rights reserved
    </footer>
</body>
</html>
